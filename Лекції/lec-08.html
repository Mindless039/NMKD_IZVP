<!DOCTYPE html>
<html>
<head>
	<title>Інструментальні засоби візуального програмування. Лекція №8 </title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">Інструментальні засоби візуального програмування. Лекція №8 </div>
		<h1>Об'єктно-орієнтоване програмування ч.1</h1>
		<h2>Основні поняття ООП</h2>

<p>
Ми живемо у світі об'єктів. Стіл, автомобіль, ручка, класна дошка - все це об'єкти. Поряд з фізичними існують так само абстрактні об'єкти, типовими представниками яких є числа. Таким чином, об'єкт - це будь-яка фізична чи абстрактна сутність. Об'єкт - це загальнофілософське поняття, яке вивчалося філософами протягом тривалого часу.
</p>
<p>
<strong>Об'єкти характеризуються атрибутами.</strong> Так атрибутами автомобіля є максимальна швидкість, потужність двигуна, колір кузова й т.д. Атрибутами підсилювача є частотний діапазон, вихідна потужність, коефіцієнт нелінійних спотворень, рівень шуму і т. д.
</p>
<p>
Крім атрибутів об'єкти володіють деякими функціональними можливостями, які в об'єктно-орієнтованому програмуванні (ООП) називають <strong>операціями</strong> або <strong>методами</strong>. Так автомобіль може їздити, корабель - плавати, комп'ютер - робити обчислення.
</p>
<p>
Таким чином, об'єкт інкапсулює атрибути і методи, приховуючи від інших об'єктів взаємодіючих з ним і які використовують його функціональність, свою реалізацію. Так для того щоб переключити телевізійну програму нам достатньо на пульті дистанційного керування набрати її номер, що запустить складний механізм, який у результаті і призведе до бажаного результату. Нам абсолютно не обов'язково знати, що відбувається в пульті дистанційного керування і телевізорі, нам лише достатньо знати, що телевізор має такою можливість. Інкапсуляція або приховування реалізації є базовою властивістю ООП. Вона дозволяє створювати призначені для користувача об'єкти, що володіють необхідними методами і далі оперувати ними, не вдаючись у структуру цих об'єктів.
</p>
<p>
<strong>Об'єкт</strong> - це екземпляр деякого класу об'єктів або просто класу. Так автомобіль Audi 6 є екземпляром класу автомобілів даної моделі, приймач Sony SW-7600G так само буде представником класу однойменних приймачів. Таким чином, клас - це абстрактне поняття. Ставлення класу і об'єкту приблизно таке ж, як платонівські ідеї та об'єкти реального світу. На UML - уніфікованій мові моделювання - клас відображається у вигляді прямокутника, розділеного на три частини. У першій міститься ім'я класу, в другій - атрибути, в третій - методи (рис. 1, а).
</p>
<p><img src="img/08001.png"></p>
<p>
Рис. 1. Зображення класу і відносин генералізації в UML: а - зображення класу; б - одиночне успадкування; с - множинне спадкування
</p>
<p>
Класи можуть бути пов'язані один з одним різними відносинами. Одним з основних таких відносин є ставлення клас - підклас, відомий в об'єктно-орієнтованому програмуванні як наслідування. Наприклад, клас автомобілів Audi 6 є підкласом легкових автомобілів, який в свою чергу входить у більший клас автомобілів, а останній є підкласом класу транспортних засобів, який крім автомобілів включає в себе літаки, кораблі поїзди і т. д. Прикладом подібних відносин, є системи класифікації в ботаніці та зоології. Ставленням, зворотним спадкоємству, є узагальнення або генералізація. Вона вказує, що якийсь клас, є більш загальним (узагальненим) класом іншого класу. Клас транспортних засобів, наприклад, є генералізацією класів автомобілів, літаків і кораблів. У UML прийнято користуватися саме поняттям генералізація, що відбилося і в символі, що представляє це ставлення: більш не зафарбована стрілка, спрямована на клас, що є узагальненням деяких класів (рис. 1, б).
</p>
<p>
При спадкуванні всі атрибути і методи батьківського класу успадковуються <strong>класом-нащадком</strong>. Спадкування може бути багаторівневим, і тоді класи, що знаходяться на нижніх рівнях ієрархії, успадкують всі властивості (атрибути і методи) всіх класів, прямими або непрямими нащадками яких вони є. Клас B успадкує атрибути і методи класу A і, отже, буде мати атрибутами A, B, C і D і методами A, B, C і D, а клас C - атрибутами A, B, C, E, F і методами A, B і E.
</p>
<p>
Крім одиничного, існує і <strong>множинне </strong>спадкування, коли клас успадковує відразу кілька класів (рис. 1, с). При цьому він успадкує властивості всіх класів, нащадком яких він є. Проте в мові PHP таке спадкування не реалізовано.
</p>
<p>
При спадкуванні одні методи класу можуть заміщатися іншими. Так, клас транспортних засобів буде мати узагальнений метод руху. У класах-нащадках цей метод буде конкретизований: автомобіль буде їздити, літак - літати, корабель - плавати. Така зміна семантики методу називається поліморфізмом. Поліморфізм - це виконання методом з одним і тим же ім'ям різних дій залежно від контексту, зокрема, від приналежності того чи іншого класу. У різних мовах програмування поліморфізм реалізується різними способами.
</p>
<p>
Іншим основним видом відносин між класами та об'єктами є агрегація. Вона означає, що один клас містить в собі агрегати (складових частин, підсистем) інших класів. Так автомобіль складається з кузова, двигуна, трансмісії і т.п., а до складу приймально-передавального пристрою входять передавач, приймач і антенно-фідерний пристрій. У UML агрегації позначаються у вигляді лінії з зафарбовані ромбом на кінці. Агрегація має кратність. Так автомобіль зазвичай містить один двигун, який у свою чергу може належати тільки одному автомобілю. Автомобіль може звичайно містити від двох до п'яти дверей. У свою чергу кожні двері можуть належати лише одному автомобілю.
</p>
<p>
Щоб звернутися до атрибутів і методів агрегату, необхідно спочатку отримати вказівник на його власника, а потім вже вибрати необхідні атрибути і методи.</p>
<p>
Хай об'єкт E має методи f1 () і f2 () (рис. 2). Щоб скористатися ними, треба спочатку отримати покажчик на кореневий об'єкт А, потім на об'єкт С, що в об'єктно-орієнтованому програмуванні зазвичай записується таким чином:
</p>
<p>A.C</p>
<p>Далі отримуємо покажчик на D, так як він є агрегатом C, і, нарешті, викликаємо необхідні методи f1 () і f2 ():</p>
<p>A.C.D.f1 ()</p> 
<p>A.C.D.f2 ()</p>

<p><img src="img/08002.png"></p>
<p>
Рис. 2. Ієрархічне представлення вкладених об'єктів
</p>
<p>
Композиція є ще одним відношенням, родини агрегації. Але якщо в агрегації агрегати належать класу чи об'єкту, то в композиції існує більш слабкий зв'язок. Так, студенти з вузом перебувають у відношенні композиції, тоді як факультети, які входять до складу вузу (тобто є його невід'ємною частиною або агрегатами), пов'язані з нею відношенням агрегації. На UML композиція позначається за допомогою незамальованих ромбів. Як і у випадку агрегації, ставлення композиції має кратність. Агрегація та композиція є підкласами класу відносин асоціації. Асоціація позначається у вигляді лінії без стрілок і ромбів та може приймати вигляд як агрегації, так і композиції. На ранніх етапах об'єктно-орієнтованого аналізу і проектування часто задаються відносини асоціацій, а свою конкретизацію у вигляді агрегацій і композицій вони отримують на більш пізніх етапах.
</p>
<p>
Існує хибна думка, що об'єктно-орієнтоване програмування є чимось складним і незрозумілим. Але об'єктна декомпозиція є нітрохи не менш природною і інтуїтивно зрозумілою, ніж алгоритмічна, яка неподільно панувала до появи ООП. У програмуванні основні поняття ООП перейшли з інших галузей знань, таких як філософія, логіка, математика і семіотика, причому, не зазнавши особливих змін, принаймні того, що стосується суті цих понять. Об'єктний спосіб декомпозиції (подання) є природним, і застосовується протягом багатьох століть. Тому не дивно, що в процесі еволюції технології програмування він зайняв належне місце і підтримується так чи інакше практично всіма сучасними алгоритмічними мовами.
</p>
<h2>Класи і об'єкти в PHP</h2>
<h3>Термінологія</h3>

<p>
<strong>Клас.</strong> Тип даних, який визначається програмістом, який включає локальні функції і локальні дані. Клас може розглядатися як шаблон для створення будь-якої кількості копій об'єкта одного і того ж типу (або класу).
</p>

<p>
<strong>Об'єкт</strong> Окрема копія структури даних, визначається класом. Визначення класу формулюється тільки один раз, після чого створюються всі необхідні об'єкти, які до нього належать.
</p>

<p>
<strong>Властивість </strong>(називається також змінна класу, атрибутом або полем-членом). Один з іменованих компонентів опису даних у визначенні класу.
</p>

<p>
<strong>Метод </strong>(називається також функцією-членом). Компонент класу, який за своїм призначенням є функцією.
</p>

<p>
<strong>Абстракція </strong>- це надання об'єкту характеристик, які відрізняють його від усіх інших об'єктів, чітко визначаючи його концептуальні межі. Основна ідея полягає в тому, щоб відокремити спосіб використання складових об'єктів даних від деталей їх реалізації у вигляді більш простих об'єктів, подібно до того, як функціональна абстракція поділяє спосіб використання функції і деталей її реалізації в термінах більш примітивних функцій, таким чином, дані обробляються функцією високого рівня за допомогою виклику функцій низького рівня. Такий підхід є основою об'єктно-орієнтованого програмування. Це дозволяє працювати з об'єктами, не вдаючись в особливості їх реалізації. У кожному конкретному випадку застосовується той чи інший підхід: інкапсуляція, поліморфізм або успадкування. Наприклад, при необхідності звернутися до прихованих даних об'єкту, слід скористатися інкапсуляцією, створивши, так звану, функцію доступу або властивість.
</p>

<p>
<strong>Успадкування.</strong> Процес визначення класу на основі іншого класу. На новий (дочірній) клас за замовчуванням поширюються всі визначення змінних екземпляра і методів із старого (батьківського) класу, але можуть бути також визначені нові компоненти або «перевизначені» визначення батьківських функцій. Прийнято вважати, що клас А успадковує свої визначення від класу В, якщо клас А визначений на основі класу В зазначеним способом.
</p>

<p>
<strong>Поліморфізм </strong>- так називають явище, при якому функції (методу) з одним і тим же ім'ям відповідає різний програмний код (поліморфний код) в залежності від того, об'єкт якого класу використовується при виклику даного методу. Поліморфізм забезпечується тим, що в класі-нащадку змінюють реалізацію методу класу-предка з обов'язковим збереженням сигнатури методу. Це забезпечує збереження незмінного інтерфейсу класу-предка і дозволяє здійснити зв'язування імені методу в коді з різними класами - з об'єкта якого класу здійснюється виклик, з того класу і береться метод з такою назвою. Такий механізм називається динамічним зв'язуванням - на відміну від статичного зв'язування, здійснюваного на етапі компіляції.
</p>

<p>
<strong>Інкапсуляція</strong> - це принцип, згідно з яким будь-який клас повинен розглядатися як чорний ящик - користувач класу повинен бачити і використовувати тільки інтерфейсну частину класу (тобто список декларованих властивостей і методів класу) і не вникати в його внутрішню реалізацію. Тому дані прийнято інкапсулювати в класі таким чином, щоб доступ до них на читання чи запису здійснювався не безпосередньо, а за допомогою методів. Принцип інкапсуляції (теоретично) дозволяє мінімізувати кількість зв'язків між класами і, відповідно, спростити незалежну реалізацію та модифікацію класів.
</p>

<p>
<strong>Приховування даних - </strong>невіддільна частина ООП, керуюча областями видимості. Є логічним продовженням інкапсуляції. Метою приховування є неможливість для користувача дізнатися або зіпсувати внутрішній стан об'єкта.
</p>

<p>
<strong>Батьківський клас</strong> (або суперклас, або базовий клас). Клас, визначення якого успадковані іншим класом.
</p>

<p>
<strong>Дочірній клас</strong> (або підклас, або похідний клас). Клас, який успадковує свої визначення від іншого класу.
</p>

<p>
<strong>Конструктор - </strong>це той же метод об'єкта, який викликається автоматично при його створенні. Як правило, конструктори використовуються для присвоєння первинних значень властивостей об'єкта. В PHP4 ім'я конструктора повинно відповідати імені класу.
</p>

<p>
<strong>Деструктор -</strong> аналогічний конструктору за винятком того, що викликається при знищенні об'єкта. Наприклад в деструктор може бути вбудована функція розриву з'єднання з базою даних або збереження файлу. Деструктори не присутні в PHP4, але в 5 версії вони є. Ім'я методу деструктора заздалегідь визначено - __destructor.
</p>

<h2>Синтаксис</h2>
<h3>Опис класу і створення об'єкта</h3>

<p>
Синтаксис для створення класу досить простий: необхідно оголосити клас, використовуючи ключове слово class, за яким слідує назва класу і фігурні дужки ({}):
</p>

<pre>
&lt;? Php
class MyClass 
{ 
// Методи класу
} 
?&gt;
</pre>

<p>
Після створення класу, новий клас може бути створено та збережено у змінній за допомогою ключового слова new:
</p>

<p>
$Ob = new MyClass
</p>

<p>
Щоб побачити вміст класу, використовується функція var_dump ():
</p>

<p>
var_dump ($Ob);
</p>

<p>
Давайте зараз спробуємо з'єднати весь перерахований вище код і додати його до вашого test.php на вашому локальному сервері.
</p>

<pre>
&lt;? Php 
class MyClass 
{ 
// Методи класу
}
$Obj = new MyClass; 
var_dump ($ obj); 
?&gt;
</pre>

<p>
Завантажте сторінку в браузері за адресою <a href="http://localhost/test.php">http://localhost/test.php</a> На дисплеї має висвітитися це:
</p>

<p>
object (MyClass) # 1 (0) {}
</p>
<p>
Можна сказати, що ми створили найпростішу програму використовуючи ООП
</p>

<h2>Визначення властивостей класу</h2>

<p>
Щоб додати до класу властивості, потрібно переробити наш клас приблизно так:
</p>

<pre>
&lt;? Php 
class MyClass 
{ 
public $prop1 = "I'm a class property!"; 
} 
$ Obj = new MyClass; 
var_dump ($obj);
?&gt;
</pre> 

<p>
<strong>Властивості класу -</strong> це специфічні змінні, які пов'язані з об'єктом класу і можуть бути доступні виключно через клас.
</p>

<p>
<strong>public -</strong> це атрибут видимості даної змінної, про які ми поговоримо трохи пізніше. Після нього слідує змінна, якій присвоюється значення "I'm a class property!";
</p>
<p
>Для виведення даної властивості у вікно браузера, необхідно написати:
</p>
<p>
echo $obj-&gt; prop1;
</p>
<p>
Оскільки може існувати кілька об'єктів класу, визначити до якого класу яка властивість відноситься можна за допомогою "-&gt;".
</p>

<p>
Давайте змінимо test.php замінивши попередній код на цей:
</p>

<pre>
&lt;? Php 
class MyClass 
{ 
public $ prop1 = "I'm a class property!"; 
} 
$Obj = new MyClass; 
echo $ obj-&gt; prop1; // Output the property 
?&gt;
</pre>

<p>Тепер в браузері ми побачимо:</p>
<p> I'm a class property!</p>

<h2>Псевдо-змінна $this</h2>
<p>
Псевдо-змінна $this доступна в тому випадку, коли метод був викликаний в контексті об'єкта. $this є посиланням на об'єкт, що викликається. Зазвичай це той об'єкт, якому належить викликаний метод, але може бути й інший об'єкт, якщо метод був викликаний статично з контексту іншого об'єкта. Це показано на наступних прикладах:
</p>
<p>
<strong>Приклад 1</strong> змінна $this в об'єктно-орієнтованій мові
</p>

<pre>
&lt;? Php 
class a 
function foo () 
if (isset ($this)) { 
echo '$this визначена ('; 
echo get_class ($this); 
echo ") \ n"; 
} Else { 
echo "\ $this не визначена. \ n"; 
} 
} 
} 

class b 
{ 
function bar () 
{ 
a:: foo (); 
} 
} 

$a = new a (); 
$a-&gt; foo (); 
a:: foo (); 
$b = new b (); 
$b-&gt; bar (); 
b::bar ();
?&gt;
</pre>

<p>Результат виконання цього прикладу:</p>
<p>$this визначена (a)</p>
<p>$this не визначена.</p>
<p>$this визначена (b) </p>
<p>$this не визначена.</p>

<h2>Визначення методів класу</h2>

<p>
<strong>Методи -</strong> це специфічні функції класу, які будуть виконувати деякі дії в класі.
</p>
<p>
Наприклад, для створення методів, які будуть встановлювати і отримувати значення властивостей класу $prop1, додайте наступні рядки до вашого коду:
</p>

<pre>
&lt;? Php 
class MyClass
{ 
public $prop1 = "I'm a class property!"; 

public function setProperty ($newval) 
{
$this-&gt; prop1 = $newval;
} 

public function getProperty () 
{ 
return $this-&gt; prop1. ""; 
} 
} 

$ Obj = new MyClass; 

echo $obj-&gt; prop1; 
?&gt;
</pre>

<p><strong>Примітка:</strong></p>
<p>Для виклику методів класу не забувайте використовувати знак долара.</p>
<p>Приклад $ ob-&gt; set ();</p>
<p>Тепер давайте спробуємо скористатися написаним вище класом шляхом модифікації файлу test.php:</p>

<pre>
&lt;? Php 
class MyClass 
{ 
public $prop1 = "Я властивість класу!"; 

public function setProperty ($newval) 
{ 
$this-&gt; prop1 = $newval; 
} 

public function getProperty () 
{ 
return $this-&gt; prop1. ""; 
} 
} 

$obj = new MyClass; 
echo $obj-&gt; getProperty (); // Дізнаємось значення властивості 
$obj-&gt; setProperty ("Я НОВА властивість класу!"); // Встановлюємо нове 
echo $obj-&gt; getProperty (); // Зчитуємо значення ще раз 
?&gt;
</pre>

<p>
У браузері ви побачите:
</p>
<p>
Я властивість класу! 
</p>
<p>
Я НОВА властивість класу!
</p>

<p>Справжню силу ООП можна побачити при створенні декількох об'єктів одного і того ж класу.</p>

<pre>
&lt;? Php 
class MyClass
{ 
public $prop1 = "Я властивість класу!"; 

public function setProperty ($ newval) 
{ 
$this-&gt; prop1 = $newval; 
}

public function getProperty () 
{ 
return $ this-&gt; prop1. ""; 
} 
}

// Створюємо два об’єкти 
$obj = new MyClass; 
$obj2 = new MyClass; 

// Дізнаємося значення $prop1 з обох об’єктів 
echo $obj-&gt; getProperty (); 
echo $obj2-&gt; getProperty ();

// Встановлюємо нові значення 
$ Obj-&gt; setProperty ("Я нове значення!"); 
$ Obj2-&gt; setProperty ("Я друге значення!");

// Виводимо $prop1 значення 
echo $ obj-&gt; getProperty ();
echo $ obj2-&gt; getProperty (); 
?&gt;
</pre>

<p>Після заміни вмісту файлу test.php ми побачимо: </p>
<p>Я властивість класу! </p>
<p>Я властивість класу! </p>
<p>Я нове значення! </p>
<p>Я друге значення!</p>

<h2>Використання конструкторів і деструкторів</h2>
<p>До таких методів відноситься метод __construct (), що дозволяє задати будь-які дії при створенні об'єкта, і метод __destruct (), що дозволяє задати дії при видаленні об'єкта (наприклад: розірвати з'єднання з базою даних). Для наочності, візьмемо приклад:</p>

<pre>
&lt;? Php
class MyClass 
{
public $prop1 = "Я властивість класу!";

public function __construct ()
{ 
echo 'Клас "', __CLASS__, '" було створено!'; 
}

public function __destruct () 
{ 
echo 'Клас "', __CLASS__, '" було знищено.'; 
} 

public function setProperty ($newval) 
{ 
$this-&gt; prop1 = $newval; 
} 

public function getProperty () 
{ 
return $this-&gt; prop1. ""; 
} 
} 

// Створення нового об'єкта 
$obj = new MyClass; 

// Отримуємо значення $ prop1 
echo $obj-&gt; getProperty (); 

// Виводимо повідомлення про закінчення файлу 
echo "End of file."; 
?&gt;
</pre>

<p>Після виконання даного коду ми побачимо наступний результат:</p>
<p>Клас "MyClass" було створено! </p>
<p>Я властивість класу! </p>
<p>Кінець файлу. </p>
<p>Клас "MyClass" було знищено.</p>

<p>Хотілося б звернути вашу увагу, що після завершення виконання скрипта, PHP автоматично звільняє пам'ять.</p>
<p><strong>Примітка:</strong></p>
<p>Константа __CLASS__ використовується для отримання імені класу, в якому вона викликається.</p>
<p>Для того, щоб знищити об'єкт вручну, нам необхідно скористатися функцією unset ()</p>
<p><strong>Невеликий приклад:</strong></p>

<pre>
&lt;? Php 
class MyClass 
{ 
public $prop1 = "Я властивість класу!"; 

public function __construct () 
{ 
echo 'Клас "', __CLASS__, '" було створено!'; 
} 

public function __destruct () 
{ 
echo 'Клас "', __CLASS__, '" було знищено.'; 
} 

public function setProperty ($newval) 
{ 
$this-&gt; prop1 = $ newval; 
} 

public function getProperty () 
{ 
return $this-&gt; prop1. ""; 
} 
} 

// Створення об'єкта 
$bj = new MyClass; 

// Отримання значення $prop1 
echo $obj-&gt; getProperty (); 

// Знищуємо об'єкт [/ b] 
unset ($obj); 

// Висновок повідомлення про закінчення файлу 
echo "Кінець файлу."; 
?&gt;
</pre>

<p>Результат виконання скрипта буде наступним:</p>
<p>Клас "MyClass" було створено!</p>
<p>Я властивість класу! </p>
<p>Клас "MyClass" було знищено. </p>
<p>Кінець файлу.</p>
<p>Конструктори в класах-батьків не викликаються автоматично. Щоб викликати конструктор, оголошений в батьківському класі, слід звернутися до методу parent:: __construct ().</p>

<h2>Успадкування</h2>

<p>
<strong>Успадкування - </strong>один з чотирьох найважливіших механізмів об'єктно-орієнтованого програмування (поряд з інкапсуляцією, поліморфізмом і абстракцією), що дозволяє описати новий клас на основі вже існуючого (батьківського), при цьому властивості і функціональність батьківського класу запозичуються новим класом.
</p>

<p>
Говорячи простими словами спадкування, це такий механізм, який дозволяє розширювати клас за рахунок методів іншого класу. Для того, щоб додати методи і властивості іншого класу, необхідно скористатися словом extends. Наприклад, щоб створити другий клас, який розширює MyClass і додає методи, ви повинні додати наступні рядки в наш тестовий файл:
</p>
<pre>
&lt;? Php 
class MyClass 
{ 
public $prop1 = "Я властивість класу!"; 

public function __construct () 
{ 
echo 'Клас "', __CLASS__, '" було створено!'; 
} 

public function __destruct () 
{ 
echo 'Клас "', __CLASS__, '" було знищено.'; 
} 

public function __toString () 
{ 
echo "Використовуємо метод toString:"; 
return $this-&gt; getProperty (); 
} 

public function setProperty ($newval) 
{ 
$this-&gt; prop1 = $newval; 
} 

public function getProperty () 
{ 
return $this-&gt; prop1. "";
} 
} 

class MyOtherClass extends MyClass 
{ 
public function newMethod () 
{ 
echo "Із нового методу з". __CLASS__. "."; 
} 
} 

// Створення об'єкта 
$newobj = new MyOtherClass; 

// Виводимо об'єкт 
echo $newobj-&gt; newMethod (); 

// Використання методу батьківського класу 
echo $newobj-&gt; getProperty (); 
?&gt;
</pre>

<h2>Заміна успадкованих методів і властивостей</h2>
<p>
Для того, щоб замінити успадкований метод батьківського класу в новому класі, необхідно просто замінити цей метод в новому класі. При цьому необхідно використовувати те ж ім'я, яке було в батьківському класі:
</p>

<pre>
&lt;? Php 
class MyClass 
{ 
public $prop1 = "Я метод класу!"; 

public function __construct () 
{ 
echo 'Клас "', __CLASS__, '" було створено!'; 
} 

public function __destruct () 
{ 
echo 'Клас "', __CLASS__, '" було знищено.'; 
} 

public function __toString () 
{ 
echo "Використовуємо метод toString:"; 
return $this-&gt; getProperty (); 
}

public function setProperty ($newval) 
{ 
$this-&gt; prop1 = $newval; 
}

public function getProperty () 
{ 
return $this-&gt; prop1. ""; 
} 
} 

class MyOtherClass extends MyClass 
{ 
public function __construct () 
{ 
echo "Новий конструктор в ". __CLASS__. ".";
} 

public function newMethod () 
{ 
echo "Із нового методу ". __CLASS__. "."; 
} 
} 

// Створення об'єкта 
$newobj = new MyOtherClass; 

// Виводимо об'єкт 
echo $newobj-&gt; newMethod (); 

// Використання методу батьківського класу 
echo $newobj-&gt; getProperty (); 
?&gt;
</pre>

<p>У результаті ми отримаємо: </p>
<p>Новий конструктор MyOtherClass. </p>
<p>З нового методу MyOtherClass. </p>
<p>Я властивість класу! </p>
<p>Клас "MyClass" було знищено.</p>
<p>Існують ситуації, коли необхідно замінивши метод у новому класі, викликати цей же метод, але тільки в батьківському класі. У таких випадках використовується оператор parent::</p>

<p><strong>Приклад:</strong></p>

<pre>
&lt;? Php 
class MyClass 
{ 
public $prop1 = "Я властивість класу!"; 

public function __construct () 
{ 
echo 'Клас "', __CLASS__, '" було створено!'; 
} 

public function __destruct () 
{ 
echo 'Клас "', __CLASS__, '" було знищено.'; 
} 

public function __toString () 
{ 
echo "Using the toString method:";
return $this-&gt; getProperty (); 
} 

public function setProperty ($newval) 
{ 
$this-&gt; prop1 = $newval; 
} 

public function getProperty () 
{ 
return $this-&gt; prop1. ""; 
} 
} 

class MyOtherClass extends MyClass 
{ 
public function __construct () 
{ 
parent:: __construct (); // Виклик конструктора батьківського класу 
echo "Новий конструктор". __CLASS__. "."; 
} 

public function newMethod () 
{ 
echo "З нового методу класу". __CLASS__. "."; 
} 
} 

// Створюємо об'єкт 
$ Newobj = new MyOtherClass; 

// Виводимо об'єкт 
echo $newobj-&gt; newMethod (); 

// Використання методу батьківського класу 
echo $ newobj-&gt; getProperty (); 
?&gt;
</pre>

<p><strong>У результаті у вікні браузера можна спостерігати:</strong></p>
<p>Коас "MyClass" було створено! </p>
<p>Новий конструктор в MyOtherClass. </p>
<p>З нового методу в MyOtherClass. </p>
<p>Я властивість класу! </p>
<p>Клас "MyClass" було знищено.</p>



			
		</div>
	</body>
	</html>